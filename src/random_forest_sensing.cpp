#include <iostream>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl_conversions/pcl_conversions.h>

#include <Eigen/Eigen>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/Vector3.h>
#include <math.h>
#include <nav_msgs/Odometry.h>
#include <random>
#include <ros/console.h>
#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>

using namespace std;

pcl::KdTreeFLANN<pcl::PointXYZ> kdtreeLocalMap;
vector<int> pointIdxRadiusSearch;
vector<float> pointRadiusSquaredDistance;

random_device rd;
default_random_engine eng(rd());
uniform_real_distribution<double> rand_x;
uniform_real_distribution<double> rand_y;
uniform_real_distribution<double> rand_w;
uniform_real_distribution<double> rand_h;

ros::Publisher _local_map_pub;
ros::Publisher _all_map_pub;
ros::Subscriber _odom_sub;

vector<double> _state;

int _obs_num;
int fix_map_type_;
double _x_size, _y_size, _z_size;
double _x_l, _x_h, _y_l, _y_h, _w_l, _w_h, _h_l, _h_h;
double _z_limit, _sensing_range, _resolution, _sense_rate, _init_x, _init_y;

bool _map_ok = false;
bool _has_odom = false;

int circle_num_;
double radius_l_, radius_h_, z_l_, z_h_;
double theta_;
uniform_real_distribution<double> rand_radius_;
uniform_real_distribution<double> rand_radius2_;
uniform_real_distribution<double> rand_theta_;
uniform_real_distribution<double> rand_z_;

sensor_msgs::PointCloud2 globalMap_pcd;
pcl::PointCloud<pcl::PointXYZ> cloudMap;

sensor_msgs::PointCloud2 localMap_pcd;
pcl::PointCloud<pcl::PointXYZ> clicked_cloud_;

void GenerateWall(double x_min, double x_max, double y_min, double y_max,
                  double z_min, double z_max,
                  pcl::PointCloud<pcl::PointXYZ> &cloudMap)
{
    int x_num, y_num, z_num;
    x_num = ceil((x_max - x_min) / _resolution);
    y_num = ceil((y_max - y_min) / _resolution);
    z_num = ceil((z_max - z_min) / _resolution);
    for (int i = 0; i < x_num; i++)
    {
        for (int j = 0; j < y_num; j++)
        {
            for (int k = 0; k < z_num; k++)
            {
                pcl::PointXYZ pt;
                pt.x = x_min + i * _resolution;
                pt.y = y_min + j * _resolution;
                pt.z = z_min + k * _resolution;
                cloudMap.push_back(pt);
            }
        }
    }
}

void GenerateCircle(double x, double y, double z, double radius, double theta,
                    pcl::PointCloud<pcl::PointXYZ> &cloudMap)
{
    x = floor(x / _resolution) * _resolution + _resolution / 2.0;
    y = floor(y / _resolution) * _resolution + _resolution / 2.0;
    z = floor(z / _resolution) * _resolution + _resolution / 2.0;

    Eigen::Vector3d translate(x, y, z);
    Eigen::Matrix3d rotate;
    rotate << cos(theta), -sin(theta), 0.0, sin(theta), cos(theta), 0.0, 0, 0, 1;

    for (double angle = 0.0; angle < 6.282; angle += _resolution / 2)
    {
        Eigen::Vector3d cpt;
        cpt(0) = 0.0;
        cpt(1) = radius * cos(angle);
        cpt(2) = radius * sin(angle);

        cpt = rotate * cpt + translate;

        pcl::PointXYZ pt;
        pt.x = cpt(0);
        pt.y = cpt(1);
        pt.z = cpt(2);
        cloudMap.push_back(pt);
    }
}

void RandomMapGenerate()
{
    pcl::PointXYZ pt_random;

    rand_x = uniform_real_distribution<double>(_x_l, _x_h);
    rand_y = uniform_real_distribution<double>(_y_l, _y_h);
    rand_w = uniform_real_distribution<double>(_w_l, _w_h);
    rand_h = uniform_real_distribution<double>(_h_l, _h_h);

    rand_radius_ = uniform_real_distribution<double>(radius_l_, radius_h_);
    rand_radius2_ = uniform_real_distribution<double>(radius_l_, 1.2);
    rand_theta_ = uniform_real_distribution<double>(-theta_, theta_);
    rand_z_ = uniform_real_distribution<double>(z_l_, z_h_);

    // generate polar obs
    for (int i = 0; i < _obs_num; i++) 
    {
        double x, y, w, h;
        x = rand_x(eng);
        y = rand_y(eng);
        w = rand_w(eng);

        if (sqrt(pow(x - _init_x, 2) + pow(y - _init_y, 2)) < 2.0)
        {
            i--;
            continue;
        }

        if (sqrt(pow(x - 19.0, 2) + pow(y - 0.0, 2)) < 2.0)
        {
            i--;
            continue;
        }

        // map to middle of the grid
        x = floor(x / _resolution) * _resolution + _resolution / 2.0;
        y = floor(y / _resolution) * _resolution + _resolution / 2.0;

        int widNum = ceil(w / _resolution);

        for (int r = -widNum / 2.0; r < widNum / 2.0; r++)
        {
            for (int s = -widNum / 2.0; s < widNum / 2.0; s++) 
            {
                h = rand_h(eng);
                int heiNum = ceil(h / _resolution);
                for (int t = -30; t < heiNum; t++) 
                {
                    pt_random.x = x + (r + 0.5) * _resolution + 1e-2;
                    pt_random.y = y + (s + 0.5) * _resolution + 1e-2;
                    pt_random.z = (t + 0.5) * _resolution + 1e-2;
                    cloudMap.points.push_back(pt_random);
                }
            }

        }
    }

    // generate circle obs
    for (int i = 0; i < circle_num_; ++i) 
    {
        double x, y, z;
        x = rand_x(eng);
        y = rand_y(eng);
        z = rand_z_(eng);

        if (sqrt(pow(x - _init_x, 2) + pow(y - _init_y, 2)) < 2.0)
        {
            i--;
            continue;
        }

        if (sqrt(pow(x - 19.0, 2) + pow(y - 0.0, 2)) < 2.0)
        {
            i--;
            continue;
        }

        x = floor(x / _resolution) * _resolution + _resolution / 2.0;
        y = floor(y / _resolution) * _resolution + _resolution / 2.0;
        z = floor(z / _resolution) * _resolution + _resolution / 2.0;

        Eigen::Vector3d translate(x, y, z);

        double theta = rand_theta_(eng);
        Eigen::Matrix3d rotate;
        rotate << cos(theta), -sin(theta), 0.0, sin(theta), cos(theta), 0.0, 0, 0,
            1;

        double radius1 = rand_radius_(eng);
        double radius2 = rand_radius2_(eng);

        // draw a circle centered at (x,y,z)
        Eigen::Vector3d cpt;
        for (double angle = 0.0; angle < 6.282; angle += _resolution / 2)
        {
            cpt(0) = 0.0;
            cpt(1) = radius1 * cos(angle);
            cpt(2) = radius2 * sin(angle);

            // inflate
            Eigen::Vector3d cpt_if;
            for (int ifx = -0; ifx <= 0; ++ifx)
            {
                for (int ify = -0; ify <= 0; ++ify)
                {
                    for (int ifz = -0; ifz <= 0; ++ifz)
                    {
                        cpt_if = cpt + Eigen::Vector3d(ifx * _resolution, ify * _resolution,
                                                    ifz * _resolution);
                        cpt_if = rotate * cpt_if + Eigen::Vector3d(x, y, z);
                        pt_random.x = cpt_if(0);
                        pt_random.y = cpt_if(1);
                        pt_random.z = cpt_if(2);
                        cloudMap.push_back(pt_random);
                    }
                }
            }
        }
    }

    cloudMap.width = cloudMap.points.size();
    cloudMap.height = 1;
    cloudMap.is_dense = true;

    ROS_WARN("Finished generate random map ");

    kdtreeLocalMap.setInputCloud(cloudMap.makeShared());

    _map_ok = true;
}

void FixMapgenerate()
{
    switch (fix_map_type_)
    {
        case 0:
        {
            RandomMapGenerate();
            break;
        }
        case 1:
        {
            GenerateWall(3.0, 4.0, 0.3, 10.0, -0.5, 5.0, cloudMap);
            GenerateWall(3.0, 4.0, -10.0, -0.3, -0.5, 5.0, cloudMap);
            break;
        }
        case 2:
        {
            GenerateCircle(3.0, 0.0, 3.0, 2.0, 0.0, cloudMap);
            break;
        }
    }
    cloudMap.width = cloudMap.points.size();
    cloudMap.height = 1;
    cloudMap.is_dense = true;

    ROS_WARN("Finished generate fixed map ");
    kdtreeLocalMap.setInputCloud(cloudMap.makeShared());

    _map_ok = true;
}

void rcvOdometryCallbck(const nav_msgs::Odometry odom)
{
    if (odom.child_frame_id == "X" || odom.child_frame_id == "O")
        return;
    _has_odom = true;

    _state = {odom.pose.pose.position.x,
                odom.pose.pose.position.y,
                odom.pose.pose.position.z,
                odom.twist.twist.linear.x,
                odom.twist.twist.linear.y,
                odom.twist.twist.linear.z,
                0.0,
                0.0,
                0.0};
}

int i = 0;
void pubSensedPoints()
{
    pcl::toROSMsg(cloudMap, globalMap_pcd);
    globalMap_pcd.header.frame_id = "world";
    _all_map_pub.publish(globalMap_pcd);
    return;
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "random_map_sensing");
    ros::NodeHandle n("~");

    _all_map_pub =
        n.advertise<sensor_msgs::PointCloud2>("/map_generator/global_cloud", 1);

    _odom_sub = n.subscribe("odometry", 50, rcvOdometryCallbck);

    n.param("init_state_x", _init_x, 0.0);
    n.param("init_state_y", _init_y, 0.0);

    n.param("map/x_size", _x_size, 50.0);
    n.param("map/y_size", _y_size, 50.0);
    n.param("map/z_size", _z_size, 5.0);
    n.param("map/obs_num", _obs_num, 50);
    n.param("map/resolution", _resolution, 0.1);
    n.param("map/circle_num", circle_num_, 40);

    n.param("ObstacleShape/lower_rad", _w_l, 0.3);
    n.param("ObstacleShape/upper_rad", _w_h, 0.8);
    n.param("ObstacleShape/lower_hei", _h_l, 3.0);
    n.param("ObstacleShape/upper_hei", _h_h, 7.0);

    n.param("ObstacleShape/radius_l", radius_l_, 7.0);
    n.param("ObstacleShape/radius_h", radius_h_, 7.0);
    n.param("ObstacleShape/z_l", z_l_, 7.0);
    n.param("ObstacleShape/z_h", z_h_, 7.0);
    n.param("ObstacleShape/theta", theta_, 7.0);

    n.param("sensing/radius", _sensing_range, 10.0);
    n.param("sensing/rate", _sense_rate, 10.0);

    n.param("map/fix_map_type", fix_map_type_, 0);

    _x_l = -_x_size / 2.0;
    _x_h = +_x_size / 2.0;

    _y_l = -_y_size / 2.0;
    _y_h = +_y_size / 2.0;

    _obs_num = min(_obs_num, (int)_x_size * 10);
    _z_limit = _z_size;

    ros::Duration(0.5).sleep();

    FixMapgenerate();

    ros::Rate loop_rate(_sense_rate);

    while (ros::ok())
    {
        pubSensedPoints();
        ros::spinOnce();
        loop_rate.sleep();
    }
}